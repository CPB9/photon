module exc

import core::{Reader, Writer, Error, Address, Time, Generator, RingBuf}
import clk::{Tick}

/// 0x9c3e
const STREAM_SEPARATOR : u16 = 39998;

enum StreamDirection {
    Uplink = 0,
    Downlink = 1,
}

enum StreamType {
    Firmware = 0,
    CmdTelem = 1,
    User = 2,
}

enum PacketType {
    Unreliable = 0,
    Reliable = 1,
    Receipt = 2,
}

enum ReceiptType {
    Ok = 0,
    PacketError = 1,
    PayloadError = 2,
    CounterCorrection = 3,
}

struct ReceiptPacket {
    recievedCounter: u16,
    recievedChecksum: u16,
    timeRecieved: Time,
}

impl ReceiptPacket {
    fn encode(&mut self, dest: *mut Writer) -> Error
}

struct DataHeader {
    streamDirection: StreamDirection,
    packetType: PacketType,
    streamType: StreamType,
    counter: u16,
    time: Tick,
}

struct Msg {
    address: u32,
    data: *const u8,
    size: usize,
}

struct PacketRequest {
    gen: Generator,
    data: *mut void,
    address: u32,
}

type StreamHandler = &Fn(*mut Reader, *mut Writer) -> Error;

struct StreamState {
    currentReliableDownlinkCounter: u16,
    currentUnreliableDownlinkCounter: u16,
    expectedReliableUplinkCounter: u16,
    expectedUnreliableUplinkCounter: u16,
}

component {
    parameters {
        packetQueue: [PacketRequest; 8],
        currentPacket: usize,
        numPackets: usize,

        fwtStream: StreamState,
        cmdTelemStream: StreamState,
        userStream: StreamState,
        inStream: RingBuf,
        inStreamData: [u8; 1024],
        currentMsg: Msg,
        hasReceiptQueued: bool,
        receiptSize: usize,
    }

    statuses {
        [1, 1, true]: fwtStream,
        [2, 1, true]: cmdTelemStream,
    }

    impl {
        fn init()
        fn tick()
        fn prepareNextMsg()
        fn getMsg() -> *const Msg
        fn acceptInput(src: *const void, size: usize)
        fn queuePacket(address: u32, gen: Generator, data: *mut void) -> bool
    }
}
